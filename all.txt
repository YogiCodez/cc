CV LAB PROGRAMS

1. Perform basic Image Handling and processing operations on the image.  
• Read an image in python  and  Convert an Image to Grayscale 
CODE:
import cv2

# Read the image
image = cv2.imread('C:/Users/dilli/OneDrive/Documents/Computer Vision/Exp 1.png')  # Replace with your image filename

# Show the original image
cv2.imshow('Original Image', image)

# Convert to grayscale
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Show the grayscale image
cv2.imshow('Grayscale Image', gray_image)

# Wait for a key press and close all windows
cv2.waitKey(0)
cv2.destroyAllWindows()


2. Perform basic Image Handling and processing operations on the image
• Read an image in python  and  Convert an Image to Blur using GaussianBlur.
CODE:

import cv2


# Read your PNG image
img = cv2.imread('C:/Documents/Computer Vision/Exp 2.png')

# Safety check if image was loaded
if img is None:
    print("Error: Image not found or path is incorrect.")
else:
    blur = cv2.GaussianBlur(img, (15, 15), 0)

    cv2.imshow('Original Image', img)
    cv2.imshow('Blurred Image', blur)

    cv2.waitKey(0)
    cv2.destroyAllWindows()


3. Perform basic Image Handling and processing operations on the image
• Read an image in python  and  Convert an Image to show outline using Canny function. 
CODE:
import cv2

img = cv2.imread('C:/Documents/Computer Vision/Exp 3.jpg')
edges = cv2.Canny(img, 100, 200)

cv2.imshow('Original Image', img)
cv2.imshow('Canny Edges', edges)

cv2.waitKey(0)
cv2.destroyAllWindows()


4. Perform basic Image Handling and processing operations on the image
• Read an image in python  and  Dilate an Image using Dilate function.
CODE:
import cv2
import numpy as np

img = cv2.imread('C:/Documents/Computer Vision/Exp 4.jpg')
kernel = np.ones((5,5), np.uint8)
dilated = cv2.dilate(img, kernel, iterations=1)

cv2.imshow('Original Image', img)
cv2.imshow('Dilated Image', dilated)

cv2.waitKey(0)
cv2.destroyAllWindows()


5. Perform basic Image Handling and processing operations on the image
• Read an image in python  and  Erode an Image using erode function.
CODE:
import cv2
import numpy as np

img = cv2.imread('C:/Documents/Computer Vision/Exp 5.jpg')
kernel = np.ones((5,5), np.uint8)
eroded = cv2.erode(img, kernel, iterations=1)

cv2.imshow('Original Image', img)
cv2.imshow('Eroded Image', eroded)

cv2.waitKey(0)
cv2.destroyAllWindows()


6. Perform basic video processing operations on the captured video
• Read captured video in python  and  display the video, in slow motion and in fast motion.
CODE:

import cv2

cap = cv2.VideoCapture('"C:\Documents\Computer Vision\WIN_20241118_12_23_30_Pro.mp4"')

while True:
    ret, frame = cap.read()
    if not ret:
        break

    cv2.imshow('Video', frame)
    
    # Wait 30ms for normal speed
    if cv2.waitKey(30) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()


7. Capture video from web Camera and  Display the video, in slow motion and in fast motion.
CODE:
import cv2

# Open the webcam
cap = cv2.VideoCapture(0)

if not cap.isOpened():
    print("Error: Cannot open webcam.")
else:
    print("Press 's' for slow motion, 'f' for fast motion, 'q' to quit.")

    delay = 30  # normal speed

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        cv2.imshow('Webcam Video', frame)

        key = cv2.waitKey(delay) & 0xFF
        if key == ord('q'):
            break
        elif key == ord('s'):
            delay = 100  # slow motion (100 ms delay)
        elif key == ord('f'):
            delay = 1    # fast motion (1 ms delay)

    cap.release()
    cv2.destroyAllWindows()


8. Scaling an image to its Bigger and Smaller sizes.
CODE:
import cv2

# Load the image
img = cv2.imread('Exp 1.png')

if img is None:
    print("Error: Image not found.")
else:
    # Resize to bigger size (double)
    bigger = cv2.resize(img, None, fx=2, fy=2, interpolation=cv2.INTER_LINEAR)

    # Resize to smaller size (half)
    smaller = cv2.resize(img, None, fx=0.5, fy=0.5, interpolation=cv2.INTER_AREA)

    # Show images
    cv2.imshow('Original Image', img)
    cv2.imshow('Bigger Image', bigger)
    cv2.imshow('Smaller Image', smaller)

    cv2.waitKey(0)
    cv2.destroyAllWindows()


9.Perform Rotation of an image to clockwise and counter clockwise direction.
CODE:
import cv2

# Load the image
img = cv2.imread("image.jpg")  # Replace with your image file

# Rotate 90 degrees clockwise
rotate_clockwise = cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)

# Rotate 90 degrees counter-clockwise
rotate_counter = cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)

# Show images
cv2.imshow("Original", img)
cv2.imshow("Clockwise Rotation", rotate_clockwise)
cv2.imshow("Counter Clockwise Rotation", rotate_counter)

cv2.waitKey(0)
cv2.destroyAllWindows()



10. Perform moving of an image from one place to another.
CODE:
import cv2
import numpy as np

# Load the image
img = cv2.imread("image.jpg")  # Replace with your image

# Get image dimensions
height, width = img.shape[:2]

# Define translation matrix: move right by 100px and down by 50px
M = np.float32([[1, 0, 100],  # shift in x (right)
                [0, 1, 50]])  # shift in y (down)

# Apply the translation
translated_img = cv2.warpAffine(img, M, (width, height))

# Show images
cv2.imshow("Original Image", img)
cv2.imshow("Moved Image", translated_img)

cv2.waitKey(0)
cv2.destroyAllWindows()


11. Perform Affine Transformation on the image.
CODE:
import cv2
import numpy as np

# Load the image
img = cv2.imread("image.jpg")  # Replace with your image
rows, cols = img.shape[:2]

# Select 3 points from original image
pts1 = np.float32([[50, 50], [200, 50], [50, 200]])

# Set new positions for the above points
pts2 = np.float32([[10, 100], [200, 50], [100, 250]])

# Get Affine Transform matrix
M = cv2.getAffineTransform(pts1, pts2)

# Apply Affine Transformation
result = cv2.warpAffine(img, M, (cols, rows))

# Show images
cv2.imshow("Original", img)
cv2.imshow("Affine Transformed", result)

cv2.waitKey(0)
cv2.destroyAllWindows()



12. Perform Perspective Transformation on the image.
CODE:
img = cv2.imread('C:/Documents/Computer Vision/Exp 1.png')
rows, cols, ch = img.shape

pts1 = np.float32([[56,65],[368,52],[28,387],[389,390]])
pts2 = np.float32([[0,0],[300,0],[0,300],[300,300]])

M = cv2.getPerspectiveTransform(pts1, pts2)
dst = cv2.warpPerspective(img, M, (300,300))

cv2.imshow('Perspective Transform', dst)
cv2.waitKey(0)
cv2.destroyAllWindows()


13. Perform Perspective Transformation on the Video.
CODE:
import cv2
import numpy as np

# Load the video
cap = cv2.VideoCapture("video.mp4")  # Replace with your video file

while True:
    ret, frame = cap.read()
    if not ret:
        break

    rows, cols = frame.shape[:2]

    # Define 4 points (source) on the current frame (assume fixed region)
    pts1 = np.float32([[100, 100], [cols - 100, 100], [100, rows - 100], [cols - 100, rows - 100]])

    # Define 4 points (destination) where you want to map the source points
    pts2 = np.float32([[0, 0], [cols, 0], [0, rows], [cols, rows]])

    # Get the perspective transformation matrix
    M = cv2.getPerspectiveTransform(pts1, pts2)

    # Apply the perspective transformation
    transformed = cv2.warpPerspective(frame, M, (cols, rows))

    # Display original and transformed video side by side
    combined = np.hstack((frame, transformed))
    cv2.imshow("Perspective Transformation (Original | Transformed)", combined)

    # Break on 'q' key
    if cv2.waitKey(20) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()


14. Perform transformation using Homography matrix.
CODE:
import cv2
import numpy as np

# Load the input image
img = cv2.imread("image.jpg")  # Replace with your image
h, w = img.shape[:2]

# Define 4 source points (corners of a tilted rectangle in image)
src_pts = np.float32([[100, 150], [400, 130], [120, 400], [420, 380]])

# Define 4 destination points (desired straight rectangle)
dst_pts = np.float32([[0, 0], [300, 0], [0, 400], [300, 400]])

# Compute the Homography matrix
H, status = cv2.findHomography(src_pts, dst_pts)

# Apply the perspective warp using the homography matrix
warped_img = cv2.warpPerspective(img, H, (300, 400))

# Show the results
cv2.imshow("Original Image", img)
cv2.imshow("Warped Image (Homography)", warped_img)
cv2.waitKey(0)
cv2.destroyAllWindows()


15. Perform transformation using Direct Linear Transformation.
CODE:'
import cv2
import numpy as np

# Read input image
img = cv2.imread("image.jpg")  # Replace with your image
h, w = img.shape[:2]

# Define 4 source points (corners of a tilted object, for example)
src_pts = np.float32([[100, 100], [400, 80], [120, 400], [420, 420]])

# Define 4 destination points (where you want to map it to)
dst_pts = np.float32([[0, 0], [300, 0], [0, 300], [300, 300]])

# Find Homography using DLT (cv2 internally uses DLT here)
H, status = cv2.findHomography(src_pts, dst_pts)

# Apply the perspective transformation
warped_img = cv2.warpPerspective(img, H, (300, 300))

# Show images
cv2.imshow("Original Image", img)

# Draw source points on original image
for pt in src_pts:
    cv2.circle(img, tuple(pt.astype(int)), 5, (0, 255, 0), -1)

cv2.imshow("Warped Image (DLT Result)", warped_img)
cv2.waitKey(0)
cv2.destroyAllWindows()


16. Perform Edge detection using canny method
CODE:
import cv2

# Load the image
img = cv2.imread("image.jpg")  # Replace with your image
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Apply Canny edge detection
edges = cv2.Canny(gray, 100, 200)

# Show the results
cv2.imshow("Original Image", img)
cv2.imshow("Edge Detected (Canny)", edges)

cv2.waitKey(0)
cv2.destroyAllWindows()

17. Perform Edge detection using Sobel Matrix along X axis
CODE:
import cv2
import numpy as np

# Load the image
img = cv2.imread("image.jpg")  # Replace with your image
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Apply Sobel operator along X-axis
sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=3)

# Convert result to absolute scale (uint8)
abs_sobelx = cv2.convertScaleAbs(sobelx)

# Show images
cv2.imshow("Original", img)
cv2.imshow("Sobel Edge - X axis", abs_sobelx)

cv2.waitKey(0)
cv2.destroyAllWindows()


18. Perform Edge detection using Sobel Matrix along Y axis
CODE:
import cv2
import numpy as np

# Load the image
img = cv2.imread("image.jpg")  # Replace with your image
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Apply Sobel operator along Y-axis
sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=3)

# Convert result to absolute scale
abs_sobely = cv2.convertScaleAbs(sobely)

# Show results
cv2.imshow("Original Image", img)
cv2.imshow("Sobel Edge - Y axis", abs_sobely)

cv2.waitKey(0)
cv2.destroyAllWindows()



19. Perform Edge detection using Sobel Matrix along XY axis
CODE:
import cv2
import numpy as np

# Load the image
img = cv2.imread("image.jpg")  # Replace with your image
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Sobel edge detection along X and Y
sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=3)  # X-axis
sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=3)  # Y-axis

# Convert to absolute scale
abs_sobelx = cv2.convertScaleAbs(sobelx)
abs_sobely = cv2.convertScaleAbs(sobely)

# Combine X and Y edges
sobel_xy = cv2.addWeighted(abs_sobelx, 0.5, abs_sobely, 0.5, 0)

# Show all results
cv2.imshow("Original Image", img)
cv2.imshow("Sobel X", abs_sobelx)
cv2.imshow("Sobel Y", abs_sobely)
cv2.imshow("Sobel XY Combined", sobel_xy)

cv2.waitKey(0)
cv2.destroyAllWindows()


20. Perform Sharpening of Image using Laplacian mask with negative center coefficient.
CODE:
import cv2
import numpy as np

# Load image in grayscale
img = cv2.imread("image.jpg", cv2.IMREAD_GRAYSCALE)  # Replace with your image

# Define Laplacian kernel with negative center
laplacian_kernel = np.array([[ 0, -1,  0],
                             [-1,  4, -1],
                             [ 0, -1,  0]])

# Apply Laplacian filter
laplacian = cv2.filter2D(img, -1, laplacian_kernel)

# Sharpened image = original + Laplacian
sharpened = cv2.add(img, laplacian)

# Show results
cv2.imshow("Original Image", img)
cv2.imshow("Laplacian Edge", laplacian)
cv2.imshow("Sharpened Image", sharpened)

cv2.waitKey(0)
cv2.destroyAllWindows()


21. Perform Sharpening of Image using Laplacian mask implemented with an extension of
diagonal neighbors,
CODE:
import cv2
import numpy as np

# Load the image in grayscale
img = cv2.imread("image.jpg", cv2.IMREAD_GRAYSCALE)  # Replace with your image

# Define extended Laplacian kernel (includes diagonals)
laplacian_kernel_diag = np.array([[-1, -1, -1],
                                   [-1,  8, -1],
                                   [-1, -1, -1]])

# Apply the Laplacian filter
laplacian = cv2.filter2D(img, -1, laplacian_kernel_diag)

# Sharpened image = original + laplacian
sharpened = cv2.add(img, laplacian)

# Show results
cv2.imshow("Original Image", img)
cv2.imshow("Laplacian Edge (With Diagonals)", laplacian)
cv2.imshow("Sharpened Image (Extended Laplacian)", sharpened)

cv2.waitKey(0)
cv2.destroyAllWindows()


22. Perform Sharpening of Image using Laplacian mask with positive center coefficient.
CODE:
import cv2
import numpy as np

img = cv2.imread('Exp 2.jpg', 0)
kernel = np.array([[0, -1, 0],
                   [-1, 5, -1],
                   [0, -1, 0]])

sharpened = cv2.filter2D(img, -1, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Positive Center Laplacian', sharpened)
cv2.waitKey(0)
cv2.destroyAllWindows()


23.Perform Sharpening of Image using unsharp masking.
CODE:
import cv2

img = cv2.imread('Exp 3.jpg')
blur = cv2.GaussianBlur(img, (9,9), 10.0)
unsharp = cv2.addWeighted(img, 1.5, blur, -0.5, 0)

cv2.imshow('Original Image', img)
cv2.imshow('Unsharp Masking', unsharp)
cv2.waitKey(0)
cv2.destroyAllWindows()


24. Perform Sharpening of Image using High-Boost Masks.
CODE:
import cv2
import numpy as np

img = cv2.imread('Exp 3.jpg', 0)
A = 4
kernel = np.array([[0, -1, 0],
                   [-1, A, -1],
                   [0, -1, 0]])

high_boost = cv2.filter2D(img, -1, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('High-Boost Masking', high_boost)
cv2.waitKey(0)
cv2.destroyAllWindows()


25. Perform Sharpening of Image using Gradient masking.
CODE:
import cv2
import numpy as np

img = cv2.imread('Exp 4.jpg', 0)
kernel = np.array([[-1, -2, -1],
                   [ 0,  0,  0],
                   [ 1,  2,  1]])

gradient_sharpen = cv2.filter2D(img, -1, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Gradient Masking', gradient_sharpen)
cv2.waitKey(0)
cv2.destroyAllWindows()


26. Insert water marking to the image using OpenCV.
CODE:
import cv2

img = cv2.imread('Exp 4.jpg')
font = cv2.FONT_HERSHEY_SIMPLEX
cv2.putText(img, '© Sakthi Manoj', (10,50), font, 1, (255,255,255), 2, cv2.LINE_AA)

cv2.imshow('Watermarked Image', img)
cv2.waitKey(0)
cv2.destroyAllWindows()

27. Do Cropping, Copying and pasting image inside another image using OpenCV.
CODE:
import cv2

img = cv2.imread('Exp 1.png')

# Check image size
h, w = img.shape[:2]

# Define region of interest within available size
roi = img[50:100, 50:100]  # 50×50 cropped region

# Paste it at 120,120 if possible
if h >= 170 and w >= 170:
    img[120:170, 120:170] = roi
else:
    print("Image too small for paste operation.")

cv2.imshow('Crop & Paste', img)
cv2.waitKey(0)
cv2.destroyAllWindows()


28. Find the boundary of the image using Convolution kernel for the given image.
CODE:
import cv2
import numpy as np

img = cv2.imread('Exp 3.jpg', 0)
kernel = np.array([[-1, -1, -1],
                   [-1,  8, -1],
                   [-1, -1, -1]])

boundary = cv2.filter2D(img, -1, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Boundary Detection', boundary)
cv2.waitKey(0)
cv2.destroyAllWindows()


29. Morphological operations based on OpenCV using Erosion technique.
CODE:
import cv2
import numpy as np

img = cv2.imread('Exp 3.jpg', 0)
kernel = np.ones((5,5), np.uint8)
eroded = cv2.erode(img, kernel, iterations=1)

cv2.imshow('Original Image', img)
cv2.imshow('Eroded Image', eroded)
cv2.waitKey(0)
cv2.destroyAllWindows()



30. Morphological operations based on OpenCV using Dilation technique.
CODE:
import cv2
import numpy as np

img = cv2.imread('Exp 1.png', 0)
kernel = np.ones((5,5), np.uint8)
dilated = cv2.dilate(img, kernel, iterations=1)

cv2.imshow('Original Image', img)
cv2.imshow('Dilated Image', dilated)
cv2.waitKey(0)
cv2.destroyAllWindows()



31. Morphological operations based on OpenCV using Opening technique.
CODE:
import cv2
import numpy as np

img = cv2.imread('Exp 4.jpg', 0)
kernel = np.ones((5,5), np.uint8)
opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Opening Operation', opening)
cv2.waitKey(0)
cv2.destroyAllWindows()


32. Morphological operations based on OpenCV using Closing technique.
CODE:
import cv2
import numpy as np

img = cv2.imread('Exp 3.jpg', 0)
kernel = np.ones((5,5), np.uint8)
closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Closing Operation', closing)
cv2.waitKey(0)
cv2.destroyAllWindows()


33. Morphological operations based on OpenCV using Morphological Gradient technique.
CODE:
import cv2
import numpy as np

img = cv2.imread('Exp 4.jpg', 0)
kernel = np.ones((5,5), np.uint8)
gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Morphological Gradient', gradient)
cv2.waitKey(0)
cv2.destroyAllWindows()


34. Morphological operations based on OpenCV using Top hat technique.
CODE:
import cv2
import numpy as np

# Load image
img_original = cv2.imread('Exp 3.jpg')

# Check if image loaded successfully
if img_original is None:
    print("Error: Image not found or path is incorrect.")
else:
    # Make a copy to work on
    img = img_original.copy()

    # Convert to grayscale
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    gray = np.float32(gray)

    # Apply Harris Corner Detection
    dst = cv2.cornerHarris(gray, blockSize=2, ksize=3, k=0.04)

    # Result is dilated for marking corners
    dst = cv2.dilate(dst, None)

    # Threshold for optimal value and mark in red
    img[dst > 0.01 * dst.max()] = [0, 0, 255]

    # Display images
    cv2.imshow('Original Image', img_original)
    cv2.imshow('Harris Corners Detected', img)

    cv2.waitKey(0)
    cv2.destroyAllWindows()



35. Morphological operations based on OpenCV using Black hat technique.
CODE:
import cv2
import numpy as np

# Load image
img_original = cv2.imread('Exp 4.jpg')

# Check if image loaded successfully
if img_original is None:
    print("Error: Image not found or path is incorrect.")
else:
    # Make a copy for marking corners
    img = img_original.copy()

    # Convert to grayscale
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # Detect corners using Shi-Tomasi method
    corners = cv2.goodFeaturesToTrack(gray, maxCorners=100, qualityLevel=0.01, minDistance=10)

    # Convert to integer values
    corners = corners.astype(int)

    # Draw small circles at each corner
    for corner in corners:
        x, y = corner.ravel()
        cv2.circle(img, (x, y), 4, (0, 255, 0), -1)

    # Display images
    cv2.imshow('Original Image', img_original)
    cv2.imshow('Shi-Tomasi Corners Detected', img)

    cv2.waitKey(0)
    cv2.destroyAllWindows()


36. Recognise watch from the given image by general Object recognition using OpenCV.
CODE:
import cv2

# Load reference image (the watch) and the scene image
img1 = cv2.imread("watch.jpg", cv2.IMREAD_GRAYSCALE)   # Reference image
img2 = cv2.imread("scene.jpg", cv2.IMREAD_GRAYSCALE)   # Scene image

# Initialize ORB detector
orb = cv2.ORB_create()

# Detect keypoints and descriptors
kp1, des1 = orb.detectAndCompute(img1, None)
kp2, des2 = orb.detectAndCompute(img2, None)

# Create BFMatcher (Brute Force)
bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)

# Match descriptors
matches = bf.match(des1, des2)

# Sort matches by distance (lower is better)
matches = sorted(matches, key=lambda x: x.distance)

# Draw top 30 matches
result = cv2.drawMatches(img1, kp1, img2, kp2, matches[:30], None, flags=2)

# Show result
cv2.imshow("Watch Recognition", result)
cv2.waitKey(0)
cv2.destroyAllWindows()


37. Using Opencv play Video in Reverse mode.
CODE:
import cv2

# Load the video
cap = cv2.VideoCapture('your_video.mp4')  # Replace with your video file

# Get total number of frames
frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))

# Loop through the video in reverse
for i in range(frame_count - 1, -1, -1):
    cap.set(cv2.CAP_PROP_POS_FRAMES, i)  # Go to frame i
    ret, frame = cap.read()
    
    if not ret:
        break

    cv2.imshow("Reverse Video", frame)
    
    if cv2.waitKey(30) & 0xFF == ord('q'):
        break

# Release resources
cap.release()
cv2.destroyAllWindows()


38. Face Detection using Opencv.
CODE:
import cv2

# Load pre-trained face detection model
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_frontalface_default.xml")

# Start webcam
cap = cv2.VideoCapture(0)

while True:
    # Read each frame
    ret, frame = cap.read()
    if not ret:
        break

    # Convert to grayscale (face detection works on gray images)
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # Detect faces
    faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5)

    # Draw rectangle around detected faces
    for (x, y, w, h) in faces:
        cv2.rectangle(frame, (x, y), (x+w, y+h), (255, 0, 0), 2)

    # Show the frame
    cv2.imshow("Face Detection", frame)

    # Exit on 'q' key
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release and close
cap.release()
cv2.destroyAllWindows()



39. Vehicle Detection in a Video frame using OpenCV .
CDOE:
import cv2
import numpy as np

img = cv2.imread('Exp 3.jpg', 0)

# Horizontal kernel
kernelx = np.array([[1, 0, -1],
                    [1, 0, -1],
                    [1, 0, -1]])

# Vertical kernel
kernely = np.array([[1, 1, 1],
                    [0, 0, 0],
                    [-1, -1, -1]])

prewittx = cv2.filter2D(img, -1, kernelx)
prewitty = cv2.filter2D(img, -1, kernely)

cv2.imshow('Original Image', img)
cv2.imshow('Prewitt X', prewittx)
cv2.imshow('Prewitt Y', prewitty)
cv2.waitKey(0)
cv2.destroyAllWindows()


40. Draw Rectangular shape and extract objects.

import cv2

# Load the image
image = cv2.imread(r"C:\Users\antoc\OneDrive\Desktop\Course CV\LAB\src\img3.jpg")  # Replace with your image path
if image is None:
    print("Image not found!")
    exit()

# Define rectangle coordinates (x, y, width, height)
x, y, w, h = 100, 100, 200, 150  # You can change these values

# Draw the rectangle on the image
rect_image = image.copy()
cv2.rectangle(rect_image, (x, y), (x + w, y + h), (0, 255, 0), 2)

# Extract the object inside the rectangle (ROI)
roi = image[y:y + h, x:x + w]

# Display the original + rectangle image
cv2.imshow("Image with Rectangle", rect_image)

# Display the extracted object
cv2.imshow("Extracted Object", roi)

# Save the extracted object if needed
cv2.imwrite("extracted_object.jpg", roi)

cv2.waitKey(0)
cv2.destroyAllWindows()

