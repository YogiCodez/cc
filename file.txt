1) Perform basic Image Handling and processing operations on the image.  
• Read an image in python  and  Convert an Image to Grayscale 

import cv2

image_path = r"path"
image = cv2.imread(image_path)

if image is None:
    print("Error: Image not found or unable to load.")
else:
    cv2.imshow('Original Image', image)

    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    cv2.imshow('Grayscale Image', gray_image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

2) Perform basic Image Handling and processing operations on the image
• Read an image in python  and  Convert an Image to Blur using GaussianBlur.

import cv2

image_path = r"path"
image = cv2.imread(image_path)

if image is None:
    print("Error: Image not found or unable to load.")
else:
    cv2.imshow("Original Image", image)

    blurred_image = cv2.GaussianBlur(image, (15, 15), 0)

    cv2.imshow("Blurred Image", blurred_image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

3) Perform basic Image Handling and processing operations on the image
• Read an image in python  and  Convert an Image to show outline using Canny function. 

import cv2

image_path = r"path"
image = cv2.imread(image_path)

if image is None:
    print("Error: Image not found or unable to load.")
else:
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    edges = cv2.Canny(gray_image, threshold1=100, threshold2=200)

    cv2.imshow("Original Image", image)
    cv2.imshow("Edge Detected (Canny)", edges)
    cv2.waitKey(0)
    cv2.destroyAll

4) Perform basic Image Handling and processing operations on the image
• Read an image in python  and  Dilate an Image using Dilate function.

import cv2
import numpy as np

image_path = r"path"
image = cv2.imread(image_path)

if image is None:
    print("Error: Image not found or unable to load.")
else:
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    kernel = np.ones((5, 5), np.uint8)

    dilated_image = cv2.dilate(gray_image, kernel, iterations=1)

    cv2.imshow("Original Image", image)
    cv2.imshow("Dilated Image", dilated_image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

5) Perform basic Image Handling and processing operations on the image
• Read an image in python  and  Erode an Image using erode function.

import cv2
import numpy as np

image_path = r"path"
image = cv2.imread(image_path)

if image is None:
    print("Error: Image not found or unable to load.")
else:
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    kernel = np.ones((5, 5), np.uint8)

    eroded_image = cv2.erode(gray_image, kernel, iterations=1)

    cv2.imshow("Original Image", image)
    cv2.imshow("Eroded Image", eroded_image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

6) Perform basic video processing operations on the captured video
• Read captured video in python  and  display the video, in slow motion and in fast motion.

import cv2

video_path = r"path"
cap = cv2.VideoCapture(video_path)

if not cap.isOpened():
    print("Error: Cannot open video.")
else:
    print("Playing video...")

    fps = int(cap.get(cv2.CAP_PROP_FPS))
    print("Original FPS:", fps)

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break
        cv2.imshow("Normal Speed", frame)
        if cv2.waitKey(int(1000 / fps)) & 0xFF == ord('q'):
            break

    cap.set(cv2.CAP_PROP_POS_FRAMES, 0)

    print("Playing in slow motion...")
    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break
        cv2.imshow("Slow Motion", frame)
        if cv2.waitKey(int(1000 / (fps / 0.5))) & 0xFF == ord('q'):
            break

    cap.set(cv2.CAP_PROP_POS_FRAMES, 0)
    print("Playing in fast motion...")
    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break
        cv2.imshow("Fast Motion", frame)
        if cv2.waitKey(int(1000 / (fps * 2))) & 0xFF == ord('q'):
            break

    cap.release()
    cv2.destroyAllWindows()

8) Scaling an image to its Bigger and Smaller sizes.

import cv2

image_path = r"path"
image = cv2.imread(image_path)

if image is None:
    print("Error: Image not found or unable to load.")
else:
    height, width = image.shape[:2]
    print(f"Original Size: {width}x{height}")

    bigger_image = cv2.resize(image, (width * 2, height * 2), interpolation=cv2.INTER_LINEAR)

    smaller_image = cv2.resize(image, (width // 2, height // 2), interpolation=cv2.INTER_AREA)

    cv2.imshow("Original Image", image)
    cv2.imshow("Bigger Image (2x)", bigger_image)
    cv2.imshow("Smaller Image (0.5x)", smaller_image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

9) Perform Rotation of an image to clockwise and counter clockwise direction.

import cv2

image_path = r"path"
image = cv2.imread(image_path)

if image is None:
    print("Error: Image not found or unable to load.")
else:
    rotated_cw = cv2.rotate(image, cv2.ROTATE_90_CLOCKWISE)
    rotated_ccw = cv2.rotate(image, cv2.ROTATE_90_COUNTERCLOCKWISE)

    cv2.imshow("Original Image", image)
    cv2.imshow("Rotated Clockwise (90°)", rotated_cw)
    cv2.imshow("Rotated Counter-Clockwise (90°)", rotated_ccw)

    cv2.waitKey(0)
    cv2.destroyAllWindows()

10) Perform moving of an image from one place to another.

import cv2
import numpy as np

image_path = r"path"
image = cv2.imread(image_path)

if image is None:
    print("Error: Image not found or unable to load.")
else:
    tx = 100  # Shift along X (right)
    ty = 50   # Shift along Y (down)

    translation_matrix = np.float32([[1, 0, tx],
                                     [0, 1, ty]])

    rows, cols = image.shape[:2]
    translated_image = cv2.warpAffine(image, translation_matrix, (cols + tx, rows + ty))

    cv2.imshow("Original Image", image)
    cv2.imshow("Translated Image (Moved)", translated_image)

    cv2.waitKey(0)
    cv2.destroyAllWindows()

11) Perform Affine Transformation on the image.

import cv2
import numpy as np

image_path = r"path"
image = cv2.imread(image_path)

if image is None:
    print("Error: Image not found or unable to load.")
else:
    rows, cols = image.shape[:2]
    pts1 = np.float32([[50, 50], [200, 50], [50, 200]])
    pts2 = np.float32([[10, 100], [200, 50], [100, 250]])

    matrix = cv2.getAffineTransform(pts1, pts2)

    result = cv2.warpAffine(image, matrix, (cols, rows))

    cv2.imshow("Original Image", image)
    cv2.imshow("Affine Transformed Image", result)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

12) Perform Perspective Transformation on the image.

import cv2
import numpy as np

image_path = r"path"
image = cv2.imread(image_path)

if image is None:
    print("Error: Image not found or unable to load.")
else:
    pts1 = np.float32([[50, 50], [300, 50], [50, 300], [300, 300]])
    pts2 = np.float32([[10, 100], [300, 50], [100, 300], [290, 290]])

    matrix = cv2.getPerspectiveTransform(pts1, pts2)
    result = cv2.warpPerspective(image, matrix, (image.shape[1], image.shape[0]))

    cv2.imshow("Original Image", image)
    cv2.imshow("Perspective Transformed Image", result)

    cv2.waitKey(0)
    cv2.destroyAllWindows()

13) Perform Perspective Transformation on the Video.

import cv2
import numpy as np

video_path = r"path"
cap = cv2.VideoCapture(video_path)

if not cap.isOpened():
    print("Error: Cannot open video.")
else:
    print("Performing Perspective Transformation...")

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        h, w = frame.shape[:2]
        pts1 = np.float32([[50, 50], [w - 50, 50], [50, h - 50], [w - 50, h - 50]])
        pts2 = np.float32([[30, 100], [w - 100, 50], [50, h - 100], [w - 50, h - 50]])

        matrix = cv2.getPerspectiveTransform(pts1, pts2)
        warped = cv2.warpPerspective(frame, matrix, (w, h))

        cv2.imshow('Original Video', frame)
        cv2.imshow('Perspective Transformed Video', warped)

        if cv2.waitKey(20) & 0xFF == ord('q'):
            break

    cap.release()
    cv2.destroyAllWindows()

14) Perform transformation using Homography matrix.

import cv2
import numpy as np

image_path = r"path"
image = cv2.imread(image_path)

if image is None:
    print("Error: Image not found or unable to load.")
else:
    height, width = image.shape[:2]
    src_pts = np.float32([[50, 50], [width - 50, 50], [50, height - 50], [width - 50, height - 50]])
    dst_pts = np.float32([[10, 100], [width - 100, 50], [100, height - 100], [width - 50, height - 50]])

    H, status = cv2.findHomography(src_pts, dst_pts)
    transformed_image = cv2.warpPerspective(image, H, (width, height))

    cv2.imshow("Original Image", image)
    cv2.imshow("Homography Transformed Image", transformed_image)

    cv2.waitKey(0)
    cv2.destroyAllWindows()

15) Perform transformation using Direct Linear Transformation.

import cv2
import numpy as np

def compute_homography_dlt(src_pts, dst_pts):
    assert len(src_pts) == len(dst_pts) and len(src_pts) >= 4, "Need at least 4 point pairs"

    A = []
    for (x, y), (x_prime, y_prime) in zip(src_pts, dst_pts):
        A.append([-x, -y, -1,  0,  0,  0, x * x_prime, y * x_prime, x_prime])
        A.append([ 0,  0,  0, -x, -y, -1, x * y_prime, y * y_prime, y_prime])

    A = np.array(A)
    U, S, Vt = np.linalg.svd(A)
    h = Vt[-1, :] / Vt[-1, -1]  # Normalize
    H = h.reshape(3, 3)
    return H

image_path = r"path"
image = cv2.imread(image_path)

if image is None:
    print("Error: Image not found.")
else:
    height, width = image.shape[:2]

    src_pts = np.float32([[50, 50], [width - 50, 50], [50, height - 50], [width - 50, height - 50]])
    dst_pts = np.float32([[30, 100], [width - 100, 70], [100, height - 120], [width - 70, height - 70]])

    H_dlt = compute_homography_dlt(src_pts, dst_pts)

    transformed_image = cv2.warpPerspective(image, H_dlt, (width, height))

    cv2.imshow("Original Image", image)
    cv2.imshow("DLT Transformed Image", transformed_image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

16) Perform Edge detection using canny method\

import cv2

image_path = r"path"
image = cv2.imread(image_path)

if image is None:
    print("Error: Unable to load the image.")
else:
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    edges = cv2.Canny(gray, threshold1=50, threshold2=150)

    cv2.imshow("Original Image", image)
    cv2.imshow("Canny Edge Detection", edges)

    cv2.waitKey(0)
    cv2.destroyAllWindows()

17) Perform Edge detection using Sobel Matrix along X axis
18) Perform Edge detection using Sobel Matrix along Y axis
19) Perform Edge detection using Sobel Matrix along XY axis

import cv2
import numpy as np

image_path = r"path"
image = cv2.imread(image_path)

if image is None:
    print("Error: Unable to load image.")
else:
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    sobel_x = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=3)
    sobel_x = cv2.convertScaleAbs(sobel_x)

    sobel_y = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=3)
    sobel_y = cv2.convertScaleAbs(sobel_y)

    sobel_xy = cv2.bitwise_or(sobel_x, sobel_y)

    cv2.imshow("Original Image", image)
    cv2.imshow("Sobel X - Vertical Edges", sobel_x)
    cv2.imshow("Sobel Y - Horizontal Edges", sobel_y)
    cv2.imshow("Sobel XY - Combined Edges", sobel_xy)

    cv2.waitKey(0)
    cv2.destroyAllWindows()

20) Perform Sharpening of Image using Laplacian mask with negative center coefficient.

import cv2
import numpy as np

image_path = r"path"
image = cv2.imread(image_path)

if image is None:
    print("Error: Unable to load image.")
else:
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    laplacian_kernel = np.array([[0, 1, 0],
                                 [1, -4, 1],
                                 [0, 1, 0]])

    laplacian = cv2.filter2D(gray, cv2.CV_64F, laplacian_kernel)
    laplacian = cv2.convertScaleAbs(laplacian)

    sharpened = cv2.subtract(gray, laplacian)

    cv2.imshow("Original Grayscale", gray)
    cv2.imshow("Laplacian (Edges)", laplacian)
    cv2.imshow("Sharpened Image", sharpened)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

21) Perform Sharpening of Image using Laplacian mask implemented with an extension of
diagonal neighbors

import cv2
import numpy as np

img = cv2.imread('path', 0)
kernel = np.array([[1, 1, 1],
                   [1, -8, 1],
                   [1, 1, 1]])

sharpened = cv2.filter2D(img, -1, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Laplacian Sharpened (Diagonal)', sharpened)
cv2.waitKey(0)
cv2.destroyAllWindows()

22) Perform Sharpening of Image using Laplacian mask with positive center coefficient.

import cv2
import numpy as np

img = cv2.imread('path', 0)
kernel = np.array([[0, -1, 0],
                   [-1, 5, -1],
                   [0, -1, 0]])

sharpened = cv2.filter2D(img, -1, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Positive Center Laplacian', sharpened)
cv2.waitKey(0)
cv2.destroyAllWindows()

23) Perform Sharpening of Image using unsharp masking.

import cv2

img = cv2.imread('path')
blur = cv2.GaussianBlur(img, (9,9), 10.0)
unsharp = cv2.addWeighted(img, 1.5, blur, -0.5, 0)

cv2.imshow('Original Image', img)
cv2.imshow('Unsharp Masking', unsharp)
cv2.waitKey(0)
cv2.destroyAllWindows()

24) Perform Sharpening of Image using High-Boost Masks.

import cv2
import numpy as np

img = cv2.imread('path', 0)
A = 4
kernel = np.array([[0, -1, 0],
                   [-1, A, -1],
                   [0, -1, 0]])

high_boost = cv2.filter2D(img, -1, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('High-Boost Masking', high_boost)
cv2.waitKey(0)
cv2.destroyAllWindows()

25) Perform Sharpening of Image using Gradient masking.

import cv2
import numpy as np

img = cv2.imread('path', 0)
kernel = np.array([[-1, -2, -1],
                   [ 0,  0,  0],
                   [ 1,  2,  1]])

gradient_sharpen = cv2.filter2D(img, -1, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Gradient Masking', gradient_sharpen)
cv2.waitKey(0)
cv2.destroyAllWindows()

26) Insert water marking to the image using OpenCV.

import cv2

img = cv2.imread('path')
font = cv2.FONT_HERSHEY_SIMPLEX
cv2.putText(img, '© Sakthi Manoj', (10,50), font, 1, (255,255,255), 2, cv2.LINE_AA)

cv2.imshow('Watermarked Image', img)
cv2.waitKey(0)
cv2.destroyAllWindows()

27) Do Cropping, Copying and pasting image inside another image using OpenCV.

import cv2

img = cv2.imread('path')

h, w = img.shape[:2]

roi = img[50:100, 50:100]  # 50×50 cropped region

if h >= 170 and w >= 170:
    img[120:170, 120:170] = roi
else:
    print("Image too small for paste operation.")

cv2.imshow('Crop & Paste', img)
cv2.waitKey(0)
cv2.destroyAllWindows()

28) Find the boundary of the image using Convolution kernel for the given image.

import cv2
import numpy as np

img = cv2.imread('path', 0)
kernel = np.array([[-1, -1, -1],
                   [-1,  8, -1],
                   [-1, -1, -1]])

boundary = cv2.filter2D(img, -1, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Boundary Detection', boundary)
cv2.waitKey(0)
cv2.destroyAllWindows()

29) Morphological operations based on OpenCV using Erosion technique.

import cv2
import numpy as np

img = cv2.imread('path', 0)
kernel = np.ones((5,5), np.uint8)
eroded = cv2.erode(img, kernel, iterations=1)

cv2.imshow('Original Image', img)
cv2.imshow('Eroded Image', eroded)
cv2.waitKey(0)
cv2.destroyAllWindows()

30) Morphological operations based on OpenCV using Dilation technique.

import cv2
import numpy as np

img = cv2.imread('path', 0)
kernel = np.ones((5,5), np.uint8)
dilated = cv2.dilate(img, kernel, iterations=1)

cv2.imshow('Original Image', img)
cv2.imshow('Dilated Image', dilated)
cv2.waitKey(0)
cv2.destroyAllWindows()

31) Morphological operations based on OpenCV using Opening technique.

import cv2
import numpy as np

img = cv2.imread('path', 0)
kernel = np.ones((5,5), np.uint8)
opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Opening Operation', opening)
cv2.waitKey(0)
cv2.destroyAllWindows()

32) Morphological operations based on OpenCV using Closing technique.

import cv2
import numpy as np

img = cv2.imread('path', 0)
kernel = np.ones((5,5), np.uint8)
closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Closing Operation', closing)
cv2.waitKey(0)
cv2.destroyAllWindows()

33) Morphological operations based on OpenCV using Morphological Gradient technique.

import cv2
import numpy as np

img = cv2.imread('path', 0)
kernel = np.ones((5,5), np.uint8)
gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Morphological Gradient', gradient)
cv2.waitKey(0)
cv2.destroyAllWindows()

34) Morphological operations based on OpenCV using Top hat technique.

import cv2
import numpy as np

img_original = cv2.imread('path')

if img_original is None:
    print("Error: Image not found or path is incorrect.")
else:
    img = img_original.copy()
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    gray = np.float32(gray)

    dst = cv2.cornerHarris(gray, blockSize=2, ksize=3, k=0.04)
    dst = cv2.dilate(dst, None)

    img[dst > 0.01 * dst.max()] = [0, 0, 255]

    cv2.imshow('Original Image', img_original)
    cv2.imshow('Harris Corners Detected', img)

    cv2.waitKey(0)
    cv2.destroyAllWindows()

35) Morphological operations based on OpenCV using Black hat technique.

import cv2
import numpy as np

img_original = cv2.imread('path')

if img_original is None:
    print("Error: Image not found or path is incorrect.")
else:
    img = img_original.copy()

    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    corners = cv2.goodFeaturesToTrack(gray, maxCorners=100, qualityLevel=0.01, minDistance=10)

    corners = corners.astype(int)

    for corner in corners:
        x, y = corner.ravel()
        cv2.circle(img, (x, y), 4, (0, 255, 0), -1)

    cv2.imshow('Original Image', img_original)
    cv2.imshow('Shi-Tomasi Corners Detected', img)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

36) Recognise watch from the given image by general Object recognition using OpenCV.

import cv2
from matplotlib import pyplot as plt

img = cv2.imread('path', 0)
plt.hist(img.ravel(), 256, [0, 256])
plt.title('Grayscale Histogram')
plt.show()

37) Using Opencv play Video in Reverse mode.

import cv2

img = cv2.imread('path', 0)
equalized = cv2.equalizeHist(img)

cv2.imshow('Original Image', img)
cv2.imshow('Equalized Image', equalized)
cv2.waitKey(0)
cv2.destroyAllWindows()

38) Face Detection using Opencv.

import cv2

img = cv2.imread('path')
median = cv2.medianBlur(img, 5)

cv2.imshow('Original Image', img)
cv2.imshow('Median Blurred Image', median)
cv2.waitKey(0)
cv2.destroyAllWindows()

39) Vehicle Detection in a Video frame using OpenCV .

import cv2
import numpy as np

img = cv2.imread('path', 0)

kernelx = np.array([[1, 0, -1],
                    [1, 0, -1],
                    [1, 0, -1]])

kernely = np.array([[1, 1, 1],
                    [0, 0, 0],
                    [-1, -1, -1]])

prewittx = cv2.filter2D(img, -1, kernelx)
prewitty = cv2.filter2D(img, -1, kernely)

cv2.imshow('Original Image', img)
cv2.imshow('Prewitt X', prewittx)
cv2.imshow('Prewitt Y', prewitty)
cv2.waitKey(0)
cv2.destroyAllWindows()

40) Draw Rectangular shape and extract objects.

import cv2

img = cv2.imread('path')
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
h, s, v = cv2.split(hsv)

cv2.imshow('Original Image', img)
cv2.imshow('Hue Channel', h)
cv2.imshow('Saturation Channel', s)
cv2.imshow('Value Channel', v)
cv2.waitKey(0)
cv2.destroyAllWindows()